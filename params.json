{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Chrono.js","tagline":"High accuracy Javascript timer and chronometer library written in CoffeeScript","body":"# Chrono.js\r\nJavascript is really bad at handling time related tasks:\r\n* It's not accurate (try it yourself at https://gist.github.com/4175664)\r\n* It's not that easy to control\r\n* Durations have to be calculated\r\n\r\nChrono.js is a library that focuses on solving these problems:\r\n* Handle time with precision\r\n* Do something at regular intervals\r\n* Easily measure durations\r\n* Make countdowns\r\n* Gives exploitable information on ellapsed / remaining time\r\n\r\n# Summary\r\n* [Usage](#usage)\r\n* [Timer](#timer)\r\n* [Chrono](#chrono)\r\n* [new Chrono()](#new-chrono)\r\n* [start(), stop(), reset()](#controls)\r\n* [handlers binding](#handlers-binding)\r\n* [ticking, settings](#attributes)\r\n* [time()](#timechanges)\r\n* [remainingTime()](#remainingtimechanges)\r\n* [Building Chorno.js](#building-chronojs)\r\n\r\n# Usage\r\nChrono.js exports 2 classes : `Chrono` and `Timer`.\r\n\r\nIncluding Chrono.js into your code is as easy as you could expect it:\r\n\r\n``` html\r\n<script src=\"chrono.min.js\"></script>\r\n```\r\n\r\nOr with require\r\n\r\n``` javascript\r\nvar chronojs = require('chrono');\r\nvar Chrono = chronojs.Chrono;\r\nvar Timer = chronojs.Timer;\r\n```\r\nGood to know : Chrono.js does not rely on any other library.\r\n\r\n# API\r\n## Timer\r\nAs said in introduction, setInterval isn't accurate and uneasy to control. Timer class fixes that.\r\n\r\nHere is an example:\r\n\r\n``` javascript\r\nTimer = require('chrono').Timer;\r\n\r\nvar timer = new Timer(100, function(){/* done every 100ms */});\r\ntimer.start();\r\n// ...\r\ntimer.stop();\r\n```\r\n\r\n## Chrono\r\n### new Chrono()\r\nChrono class will help you to measure passing time and make countdown.\r\nImportation and creation is easy.\r\n\r\n``` javascript\r\nvar Chrono  = require('chrono').Chrono\r\n\r\nvar chrono = new Chrono([settings], [*handlers]);\r\n```\r\n\r\n#### Settings\r\nSettings object may have these following attributes:\r\n\r\n`precision` : time between ticks. Default is one second\r\n\r\n`startFrom` : current time value when Chrono starts (first start or reset)\r\n\r\n`stopTo` : Chrono stops when reaching this time\r\n\r\nThese time related values can be passed in several equivalent ways, here is an example for 1 hour, 2 minutes, 3 seconds and 4 milliseconds\r\n* as number in milliseconds\r\n * 3723004\r\n* as string\r\n * '1h 2m 3s 4ms'\r\n * '1h2m 3s 4ms' // spaces between units are optionnal\r\n * '2m 4ms 1h 3s' // order is not important\r\n* as an object\r\n * {h:1, m:2, s:3, ms:4}\r\n\r\nHere is a complete example:\r\n\r\n``` javascript\r\nchrono = new Chrono({\r\n  precision:100,\r\n  startFrom: \"1m 30s\",\r\n  stopTo: {\r\n    h: 2\r\n    m: 30,\r\n    s:10\r\n  }\r\n});\r\n```\r\nFor most case, you just need ot pass `precision`. You can pass it directly as a string or as a number but not as an Object:\r\n  \r\n``` javascript\r\nchrono = new Chrono(1100); // OK\r\nchrono = new Chrono('1s 100ms'); // OK\r\nchrono = new Chrono({s:1 ms:100}); // not OK\r\n```\r\n\r\n#### Handlers\r\n`handlers` params are the event callbacks. They will be called with `milliseconds`, `chrono` and `flag` parameters.\r\n\r\n`milliseconds` is the amount of milliseconds the Chrono counted by the chrono while ticking. Calling `time()` will provide you nicer values but we didn't want to make potentially useless computation unless you ask for it.\r\n  \r\n`chrono` is the source of the calling so you don't have to save the reference.\r\n\r\n`flag` is the reason why the handler was called. It can be either `tick`, `start`, `stop` or `end`\r\n\r\n``` javascript\r\nc = new Chrono({ms:100}, function(ticks, chrono, flag) { // tick every 100ms\r\n  console.log(\"ticks \" + ticks);\r\n});\r\n```\r\n\r\n### Controls\r\nYou can use the 3 self-explained chainable functions:\r\n\r\n* `start()`\r\n* `stop()`\r\n* `reset([settings])`\r\n\r\nFew details:\r\n\r\n* `stop` do not reset the number of ticks, it just stops the ticking.\r\n* `stop` is not a toggle, you have to call `start`\r\n* You can change settings when calling settings with the same format as in the constructor. Only difference, you can't directly pass a precision as an object (but it's ok as a string or number).\r\n* `reset` will stop the Chrono so you don't have to do it first, chaining it with `start()` is easy a nice way to take new settings into account.\r\n\r\n``` javascript\r\n// 100ms Chrono\r\nchrono = new Chrono({precision:100});\r\nchrono.start();\r\n// ... restart from 1 minute with a 5 seconds precision\r\nchrono.reset({\r\n  startFrom:'1m',\r\n  precision: '5s'\r\n}).start();\r\n```\r\n\r\n### Handlers binding\r\nYou can easily bind / unbind handlers:\r\n\r\n``` javascript\r\nvar handler = function(ticks, chrono, flag) {\r\n  console.log('flag:' + flag);\r\n};\r\n  \r\nvar anotherOne = function(){\r\n  console.log('tic'); \r\n};\r\n\r\nvar chrono = new Chrono('200ms');\r\n  \r\nchrono.bind(handler, anotherOne);\r\n// ...\r\nchrono.unbind(anotherOne); // This one would be annoying\r\n```\r\n\r\n### Attributes\r\nYou can access these read-only attributes:\r\n* `ticking`\r\n* `settings`, the default settings merged with the settings you passed\r\n\r\n```javascript\r\nchrono = new Chrono({precision:100});\r\nchrono.ticking;\r\n>false\r\nchrono.start().ticking;\r\n>true\r\nchrono.stop().ticking;\r\n>false\r\nchrono.start().reset().ticking;\r\n>false\r\n```\r\n\r\n### `time([changes])`\r\n`time()` is a read/write function on ellapsed time.\r\nIt will always return the current ellapsed time as an object with `ms`, `s`, `m`, `h` attributes which are computed based on ellpased time.\r\n  \r\nQuick example:\r\n``` javascript\r\n\r\nvar chrono = new Chrono({}, function(ms, ch, flag){\r\n  \r\n  if(ms === 130000) { // 2min, 10sec\r\n    console.log(ch.time()); // outputs {h:0, m:2, s:10, ms:0}\r\n  }\r\n});\r\n```\r\n\r\nIt can take changes as parameters. For now, it only takes it as a string. Here are a few examples:\r\n``` javascript\r\nvar chrono = new Chrono();\r\nchrono.time('1s'); // {h:0, m:0, s:1, ms:0}\r\nchrono.time('+2s'); // {h:0, m:0, s:3, ms:0}\r\nchrono.time('+3m'); // {h:0, m:3, s:3, ms:0}\r\nchrono.time('*5m'); // {h:0, m:15, s:3, ms:0}\r\nchrono.time('-5m 10s'); {h:0, m:10, s:10, ms:0}, handles several changes at one\r\nchrono.time('/2m'); {h:0, m:5, s:0, ms:0}\r\nchrono.time('+5h1500ms'); {h:5, m:10, s:11, ms:500}, spaces are optionnal\r\n```\r\n  \r\n### `remainingTime([changes])`\r\n`remainingTime()` works the very like `time()` except it's related to the time until `stopTo` is reached. It will return the same type of time object when called and can take changes into account if needed. Changes will be applied by changing the settings.stopTo value.\r\n  \r\nIt will return `undefined` if no value has been set to `stopTo`.\r\n  \r\nHere is an example :\r\n  \r\n```javascript\r\nvar chrono = new Chrono({\r\n  startFrom:'3m10s',\r\n  stopTo:'5m42s'\r\n});\r\n\r\nconsole.log chrono.remainingTime();\r\n// outputs : {h:0, m:2, s:32, ms:0}\r\n\r\nconsole.log chrono.remaningTime('+2m -12s');\r\n// outputs : {h:0, m:4, s:20, ms:0}\r\n  \r\nconsole.log chrono.time();\r\n// outputs : {h:0, m:3, s:10, ms:0} as current time never changed\r\n```\r\n\r\n# Building Chrono.js\r\nIf you want to build Chrono.js from its source, you can just use grunt.\r\nSeveral tasks are available:\r\n\r\n* `grunt` builds Chrono.js and run fast (<1sec) tests\r\n* `grunt build` builds Chrono.js without running any tests (you don't want that)\r\n* `grunt longtest` builds and run long tests (2 minutes and more)\r\n* `grunt buildDemo` builds Chrono.js, runs tests and builds the demo files\r\n* `grunt watchDemo` is buildDemo + watch any file update to re-run and refresh Chrome\r\n\r\nYou don't have to run long tests unless you change something because I already run them for you."}